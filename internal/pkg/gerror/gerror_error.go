package gerror

import (
	"bytes"
	"fmt"
	"runtime"
	"strings"
)

var goRootForFilter = runtime.GOROOT()

func init() {
	if goRootForFilter != "" {
		goRootForFilter = strings.Replace(goRootForFilter, "\\", "/", -1)
	}
}

type Error struct {
	error error
	stack stack
	text  string
}

//Error 实现error接口
func (err *Error) Error() (text string) {
	if err == nil {
		return ""
	}

	text = err.text

	if err.error != nil {
		if text != "" {
			text += ": "
		}
		text += err.error.Error()
	}

	return
}

func (err *Error) Stack() string {
	if err == nil {
		return ""
	}

	var (
		loop   = err
		index  = 1
		buffer = bytes.NewBuffer(nil)
	)

	for loop != nil {
		buffer.WriteString(fmt.Sprintf("Error: %s\n", loop.Error()))
		buffer.WriteString(fmt.Sprintf("StackTrace (most recent call last):\n"))
		index++
		formatSubStack(loop.stack, buffer)

		if loop.error != nil {
			if e, ok := loop.error.(*Error); ok {
				loop = e
			} else {
				fmt.Println(loop.error.Error())
				buffer.WriteString(fmt.Sprintf("%d.%s\n", index, loop.error.Error()))
				index++
				break
			}
		} else {
			break
		}
	}

	return buffer.String()
}

// formatSubStack formats the stack for error.
func formatSubStack(st stack, buffer *bytes.Buffer) {
	if st == nil {
		return
	}
	index := 1
	space := "  "
	for _, p := range st {
		if fn := runtime.FuncForPC(p - 1); fn != nil {
			file, line := fn.FileLine(p - 1)

			// Avoid stack string like "`autogenerated`"
			if strings.Contains(file, "<") {
				continue
			}

			if goRootForFilter != "" &&
				len(file) >= len(goRootForFilter) &&
				file[0:len(goRootForFilter)] == goRootForFilter {
				continue
			}

			// Graceful indent.
			if index > 9 {
				space = "  "
			}

			buffer.WriteString(fmt.Sprintf("%d. %s:%d\n  %s%s()\n", index, file, line, space, fn.Name()))
			index++
		}
	}
}
